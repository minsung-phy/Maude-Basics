mod RESCUE-MULTI-2D is
    protecting NAT .   --- 자연수
    protecting BOOL .  --- Bool (true/false 등)

    --- 2D 위치 정의 (X,Y)
    sort Pos .
    op (_,_) : Nat Nat -> Pos [ctor] .

    --- 플레이어, 피해자, 전체 상태
    sorts Player Victim State .

    --- 플레이어 : (ID, 위치)
    op player : Nat Pos -> Player [ctor] .

    --- 피해자 : (ID, 위치, 구조 여부, 데드라인)
    --- victim(VID, Pos, rescued?, deadline)
    op victim : Nat Pos Bool Nat -> Victim [ctor] .

    --- 전체 상태 : (시간 T, 플레이어 2명, 피해자 2명)
    op state : Nat Player Player Victim Victim -> State [ctor] .

    --- 맵 크기 (0..maxX, 0..maxY)
    op maxX : -> Nat [ctor] .
    op maxY : -> Nat [ctor] .
    eq maxX = 2 .   --- X = 0,1,2  -> 3칸
    eq maxY = 2 .   --- Y = 0,1,2  -> 3칸

    --- 자연수 감소 함수 (왼쪽/아래 이동용)
    op dec : Nat -> Nat .
    eq dec(0) = 0 .
    eq dec(s N) = N .

    --- 변수 선언
    vars N : Nat .
    vars T D1 D2 : Nat .
    vars X1 Y1 X2 Y2 : Nat .
    vars VID1 VID2 : Nat .
    vars P1 P2 : Player .
    vars Pos1 Pos2 : Pos .
    vars R1? R2? : Bool .
    vars V1 V2 : Victim .
    var  S : State .

    --- 초기 상태
    --- 시간: 0
    --- 플레이어 0: (0,0)
    --- 플레이어 1: (2,2)
    --- 피해자 0:  (0,2), 데드라인 4
    --- 피해자 1:  (2,0), 데드라인 5
    op init : -> State .
    eq init =
    state(0,
            player(0, (0,0)),
            player(1, (2,2)),
            victim(0, (0,2), false, 4),
            victim(1, (2,0), false, 5)) .

    ----------------------------------------------------------------------
    --- 이동 규칙 (플레이어 0)
    ----------------------------------------------------------------------

    --- P1: 오른쪽 이동 (X -> X+1)
    crl [move-P1-right] :
    state(T,
            player(0, (X1, Y1)),
            P2,
            V1,
            V2)
    =>
    state(s T,
            player(0, (s X1, Y1)),
            P2,
            V1,
            V2)
    if X1 < maxX .

    --- P1: 왼쪽 이동 (X -> dec(X))
    crl [move-P1-left] :
    state(T,
            player(0, (X1, Y1)),
            P2,
            V1,
            V2)
    =>
    state(s T,
            player(0, (dec(X1), Y1)),
            P2,
            V1,
            V2)
    if X1 > 0 .

    --- P1: 위쪽 이동 (Y -> Y+1)
    crl [move-P1-up] :
    state(T,
            player(0, (X1, Y1)),
            P2,
            V1,
            V2)
    =>
    state(s T,
            player(0, (X1, s Y1)),
            P2,
            V1,
            V2)
    if Y1 < maxY .

    --- P1: 아래쪽 이동 (Y -> dec(Y))
    crl [move-P1-down] :
    state(T,
            player(0, (X1, Y1)),
            P2,
            V1,
            V2)
    =>
    state(s T,
            player(0, (X1, dec(Y1))),
            P2,
            V1,
            V2)
    if Y1 > 0 .

    ----------------------------------------------------------------------
    --- 이동 규칙 (플레이어 1)
    ----------------------------------------------------------------------

    --- P2: 오른쪽 이동
    crl [move-P2-right] :
    state(T,
            P1,
            player(1, (X2, Y2)),
            V1,
            V2)
    =>
    state(s T,
            P1,
            player(1, (s X2, Y2)),
            V1,
            V2)
    if X2 < maxX .

    --- P2: 왼쪽 이동
    crl [move-P2-left] :
    state(T,
            P1,
            player(1, (X2, Y2)),
            V1,
            V2)
    =>
    state(s T,
            P1,
            player(1, (dec(X2), Y2)),
            V1,
            V2)
    if X2 > 0 .

    --- P2: 위쪽 이동
    crl [move-P2-up] :
    state(T,
            P1,
            player(1, (X2, Y2)),
            V1,
            V2)
    =>
    state(s T,
            P1,
            player(1, (X2, s Y2)),
            V1,
            V2)
    if Y2 < maxY .

    --- P2: 아래쪽 이동
    crl [move-P2-down] :
    state(T,
            P1,
            player(1, (X2, Y2)),
            V1,
            V2)
    =>
    state(s T,
            P1,
            player(1, (X2, dec(Y2))),
            V1,
            V2)
    if Y2 > 0 .

    ----------------------------------------------------------------------
    --- 구조 규칙 (같은 칸에 있을 때만 구조)
    ----------------------------------------------------------------------

    --- P1 이 V1 구조
    rl [rescue-P1-V1] :
    state(T,
            player(0, Pos1),
            P2,
            victim(0, Pos1, false, D1),
            V2)
    =>
    state(s T,
            player(0, Pos1),
            P2,
            victim(0, Pos1, true, D1),
            V2) .

    --- P1 이 V2 구조
    rl [rescue-P1-V2] :
    state(T,
            player(0, Pos1),
            P2,
            V1,
            victim(1, Pos1, false, D2))
    =>
    state(s T,
            player(0, Pos1),
            P2,
            V1,
            victim(1, Pos1, true, D2)) .

    --- P2 가 V1 구조
    rl [rescue-P2-V1] :
    state(T,
            P1,
            player(1, Pos2),
            victim(0, Pos2, false, D1),
            V2)
    =>
    state(s T,
            P1,
            player(1, Pos2),
            victim(0, Pos2, true, D1),
            V2) .

    --- P2 가 V2 구조
    rl [rescue-P2-V2] :
    state(T,
            P1,
            player(1, Pos2),
            V1,
            victim(1, Pos2, false, D2))
    =>
    state(s T,
            P1,
            player(1, Pos2),
            V1,
            victim(1, Pos2, true, D2)) .

    ----------------------------------------------------------------------
    --- 분석용 함수들: allRescued / deadlineMiss
    ----------------------------------------------------------------------

    --- 모든 피해자가 구조되었는지?
    op allRescued : State -> Bool .

    eq allRescued(
        state(T,
                P1,
                P2,
                victim(0, Pos1, true, D1),
                victim(1, Pos2, true, D2)))
    = true .

    --- 데드라인 위반 상태가 있는지?
    op deadlineMiss : State -> Bool .

    --- 피해자 0이 데드라인 초과인데 아직 구조 안 된 경우
    ceq deadlineMiss(
        state(T,
                P1,
                P2,
                victim(0, Pos1, false, D1),
                V2))
    = true
    if T > D1 .

    --- 피해자 1이 데드라인 초과인데 아직 구조 안 된 경우
    ceq deadlineMiss(
        state(T,
                P1,
                P2,
                V1,
                victim(1, Pos2, false, D2)))
    = true
    if T > D2 .

    endm

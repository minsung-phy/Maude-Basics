mod MINI-C is
    protecting MINI-C-SYNTAX .

    ----------------------------------------------------------------------
     --- 1. 환경(Environment) : Id -> Int
    ----------------------------------------------------------------------
    sorts Env Binding .
    subsort Binding < Env .

    op emptyEnv : -> Env [ctor] .
    op _&_      : Binding Env -> Env [ctor] .       --- Binding & 나머지 환경
    op _|->_    : Id Int -> Binding [ctor] .        --- x |-> 3

    --- lookup / update 
    op lookup : Id Env -> Int [ctor] .
    op update : Id Int Env -> Env [ctor] .

    --- 선언 안 된 변수는 0이라고 가정
    eq lookup(X, emptyEnv)          = 0 .
    eq lookup(X, (X |-> N) & E)     = N .
    ceq lookup(X, (Y |-> N) & E)    = lookup(X, E)
        if X =/= Y .

    eq update(X, N, emptyEnv)       = (X |-> N) & emptyEnv .
    eq update(X, N, (X |-> M) & E)  = (X |-> N) & E .
    ceq update(X, N, (Y |-> M) & E) = (Y |-> M) & update(X, N, E)
        if X =/= Y .

    ----------------------------------------------------------------------
    --- 2. 출력(Out)
    ----------------------------------------------------------------------
    sort Out .
    op nilOut : -> Out [ctor] .
    op _:_    : Int Out -> Out [ctor] .     --- 3 : 5 : nilOut

    ----------------------------------------------------------------------
    --- 3. Heap : 주소(Int) -> 값(Int)
    ----------------------------------------------------------------------
    sorts Heap HCell .
    subsort HCell < Heap .

    --- 빈 힙과 셀
    op emptyHeap : -> Heap [ctor] .
    op _&_       : HCell Heap -> Heap [ctor] .        --- 셀 & 나머지 힙
    op _|=>_     : Int Int -> HCell [ctor] .        --- addr |=> value

    --- Heap 연산
    op maxAddr  : Heap -> Int . --- Heap 안에서 가장 큰 주소
    op alloc    : Heap -> Int . --- fresh 주소
    op load     : Int Heap -> Int . --- 메모리 읽기
    op store    : Int Int Heap -> Heap . --- 메모리 쓰기
    op free     : Int Heap -> Heap . --- 메모리 해제

    eq maxAddr(emptyHeap)       = 0 .
    eq maxAddr((A |=> V) & H)   = 
        if A >= maxAddr(H) then A else maxAddr(H) fi .
    
    eq alloc(H) = maxAddr(H) + 1 .

    eq load(A, (A |=> V) & H) = V .
    ceq load(A, (A' |=> V) & H) = load(A, H) 
        if A =/= A' .
    eq load(A, emptyHeap) = 0 .

    eq store(A, V, emptyHeap)       = (A |=> V) & emptyHeap .
    eq store(A, V, (A |=> W) & H)   = (A |=> V) & H .
    ceq store(A, V, (A' |=> W) & H) = (A' |=> W) & store(A, V, H)
        if A =/= A' .    

    eq free(A, emptyHeap)       = emptyHeap .
    eq free(A, (A |=> V) & H)   = H .
    ceq free(A, (A' |=> V) & H) = (A' |=> V) & free(A, H)
        if A =/= A' .

    ----------------------------------------------------------------------
    --- 4. 정수 / Bool 식 평가
    ----------------------------------------------------------------------
    --- 정수식 평가: eval : Int(식) × Env -> Int(값)
    op eval : Int Env -> Int .

    vars A A' A1 A2 : Int .
    vars X Y        : Id .
    var E           : Env .

    eq eval(var(X), E)  = lookup(X, E) .
    eq eval(A1 + A2, E) = eval(A1, E) + eval(A2, E) .
    eq eval(A1 - A2, E) = eval(A1, E) - eval(A2, E) .
    eq eval(A1 * A2, E) = eval(A1, E) * eval(A2, E) .
    eq eval(A1 / A2, E) = divInt(eval(A1, E), eval(A2, E)) .
    --- 나머지 Int 식(상수 등)은 그대로 값으로 둠
    eq eval(A, E) = A [owise] .

    --- 정수 나눗셈 정의 (0 이상, 양수 나눗셈만 / Maude INT에 정의되어있지 않음)
    op divInt : Int Int -> Int .

    vars I J : Int .
    ceq divInt(I, J) = 0
       if I >= 0 and J > 0 and I < J .
    ceq divInt(I, J) = divInt(I - J, J) + 1
        if I >= 0 and J > 0 and I >= J .

    --- Bool 식 평가: evalB : Bool x Env -> Bool
    op evalB : Bool Env -> Bool .

    vars B B1 B2 : Bool .

    eq evalB(A1 <  A2, E) = (eval(A1, E) <  eval(A2, E)) .
    eq evalB(A1 >  A2, E) = (eval(A1, E) >  eval(A2, E)) .
    eq evalB(A1 <= A2, E) = (eval(A1, E) <= eval(A2, E)) .
    eq evalB(A1 >= A2, E) = (eval(A1, E) >= eval(A2, E)) .

    --- 논리 연산
    eq evalB(not B, E)     = not evalB(B, E) .
    eq evalB(B1 and B2, E) = evalB(B1, E) and evalB(B2, E) .
    eq evalB(B1 or  B2, E) = evalB(B1, E) or  evalB(B2, E) .
    eq evalB(B1 xor B2, E) = evalB(B1, E) xor evalB(B2, E) .

    --- Bool 리터럴 (패턴이 안맞을 때)
    eq evalB(true, E)  = true .
    eq evalB(false, E) = false .

    ----------------------------------------------------------------------
    --- 5. 전체 구성 / 초기 상태
    ----------------------------------------------------------------------
    sort Config .
    op <_,_,_,_> : Env Heap StmtList Out -> Config [ctor] .

    --- 초기 상태
    op init : StmtList -> Config .
    eq init(SL) = < emptyEnv, emptyHeap, SL, nilOut > .

    --- 변수 선언
    vars SL SL1 SL2 BODY : StmtList .
    vars N M P V W       : Int .
    vars Bcond           : Bool .
    var O                : Out .
    var H                : Heap .

    ----------------------------------------------------------------------
    --- 6. Rewrite Rules
    ----------------------------------------------------------------------

    --- 대입문: X := A;
    rl [assign] :
        < E , H , (X := A) ; SL , O >
    =>
        < update(X, eval(A, E), E) , H , SL , O > .

    --- printf(A);
    rl [printf] :
        < E , H , printf(A) ; SL , O >
    =>
        < E , H , SL , eval(A, E) : O > .

    --- skip; S  ->  S
    rl [skip] :
        < E , H , skip ; SL , O >
    =>
        < E , H , SL , O > .

    --- if 문
    crl [if-true] :
        < E , H , ifStmt(B, SL1, SL2) ; SL , O >
    =>
        < E , H , SL1 ; SL , O >
    if evalB(B, E) == true .

    crl [if-false] :
        < E , H , ifStmt(B, SL1, SL2) ; SL , O >
    =>
        < E , H , SL2 ; SL , O >
    if evalB(B, E) == false .

    --- while B do BODY od
    ---  -> if B then BODY ; while B do BODY od else skip fi
    rl [while] :
        < E , H , whileStmt(B, BODY) ; SL , O >
    =>
        < E , H , ifStmt(B, 
                         BODY ; (whileStmt(B, BODY) ; nil), 
                         skip ; nil) ;
          SL , O > .

    --- for (Init; Cond; Step) Body
    ---  -> Init ; while (Cond) { Body; Step }
    rl [for] :
        < E , H , forStmt(SL1, B, SL2, BODY) ; SL , O >
    => 
        < E , H , 
            SL1 ; 
            whileStmt(B, BODY ; SL2) ;
            SL , O > .

    --- X = malloc(n);
    rl [malloc] :
        < E , H , mallocS(X, N) ; SL , O >
    =>
        < update(X, alloc(H), E) , 
          store(alloc(H), 0 , H) , 
          SL , O > .

    --- X = *p;
    rl [load] :
        < E, H, loadS(X, P) ; SL , O >
    =>
        < update(X, load(eval(P, E), H), E) ,
          H , 
          SL , O > .

    --- *p = v;
    rl [store] :
        < E , H , storeS(P, V) ; SL , O >
    =>
        < E , 
          store(eval(P, E), eval(V, E), H) , 
          SL , O > .

    --- free(p);
    rl [free] : 
        < E , H , freeS(P) ; SL , O >
    =>
        < E , 
          free(eval(P, E), H) , 
          SL , O > .    
endm